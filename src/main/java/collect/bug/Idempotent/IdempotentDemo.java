package collect.bug.Idempotent;

/**
 * @author wzq
 * Created on 2022-10-08
 */
public class IdempotentDemo {

    /**
     * Demo 1:
     * Under the same business, the upstream call to pay the first debit of 100 was successful, due to the number
     * generation problems leading to another use of the same single number debit of 500, at this time the upstream
     * business got the same single number two requests for business parameters inconsistent error code, will be
     * considered in processing, and then the call to check the bill will return the first successful results, at
     * this time the capital loss occurred.
     */

    /**
     * Demo 2:
     * The transaction generates an idempotent order number to inert the business record while requesting the remote
     * idempotent interface. When the remote idempotent interface call times out but the actual interface server has
     * succeeded, the local transaction is rolled back causing a loss of capital.
     */
    public void  Demo() {
        // DataSourceTransactions.trx(payShard, tpl -> {        // 1. Generated idempotent order number in buildRecord

            // TransferKsCoinRecord record = buildRecord();
            // transferKsCoinRecordDAO.insertInTrx(tpl, record); // 2. insert DB
            //  TransferResponse response = TransferKcCoinClient.transfer(buildTransferRequest(record));  // 3. payment
            // 4. update result

        // });
    }
        // When a timeout occurs in step 3, the entire transaction is rolled back, but the downstream may have been executed to payment as a success




    /**
     *  follow the rules
     *  【For callers】
     * 1、The rules for generating idempotent order numbers should be unique within the business field.
     *
     * 2、Idempotent numbers need to be generated during the pre-processing phase and need to be landed in time (before
     * the call is initiated downstream) and not allowed to be updated after landing (including format type
     * conversions).
     *
     * 3、The full idempotent number needs to be landed on a database field and is not recommended to be generated by
     * in-memory splicing.
     *
     * 4、It is not allowed to land a local business record in a transaction while calling a remote idempotent interface.
     *
     * 5、When an idempotent or idempotent key generation rule is changed or migrated, it is important to ensure that
     * there are no duplication or incompatibility issues with the co-existence of old and new rules.
     *
     * 【For service providers】
     * 1、Reasonably set the validity period of the idempotent verification data persistence, it is recommended that at
     *  least three months, which can be combined with business scenarios to determine.
     * 	 - Mainly for data archiving, expiration and other scenarios
     *
     *  2、idempotent verification found previously processed business data, the need to request parameters and
     * previous data for key information verification, when inconsistencies occur, the need to throw the relevant
     * error code prompting manual intervention to investigate.
     * 	 - This is particularly important and can be easily overlooked
     *   - Definition of key information: core business parameters, such as account id, amount, product quantity,etc.
     *
     * 3、The service provider must ensure consistency in the processing and results of the same idempotent request.
     * 	 - For the same request, no matter how many times the caller requests it, the service provider should
     * 	    only process it once, and the end-state result returned by multiple requests remains the same
     * 	 - The implementation logic of the idempotent interface should give priority to idempotent judgement,
     * 	   followed by business legitimacy judgement
     */
}
